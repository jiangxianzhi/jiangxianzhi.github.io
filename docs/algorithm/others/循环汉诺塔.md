# 循环汉诺塔

## 描述
Eli最近迷上了汉诺塔。她玩了传统汉诺塔后突发奇想，发明了一种新的汉诺塔玩法。
有A、B、C三个柱子顺时针放置，移动的次序为A仅可以到B，B仅可以到C、C仅可以到A。即只可顺时针移动，不可逆时针移动。当然，汉诺塔的普适规则是适用的：每次移动后，大金片必须在小金片的下面。
现在A柱子上有n n 个金片。Eli想知道，她把这些全部移动到B或C，分别要多少次操作？

## 思路
利用状态转移方程，由于不用求具体过程，找到一步步叠加的状态。\

 AB(N) :表示N个移动一格
 AC(N) ：表示N个移动两格

找到规律：AB(1) = 1;
AC(1) = 2;
AB(2) = 5;
AC(2) =7;
AC(1) =2 *AB(1);
AC(2)< 2*AB(2);
所以当要移动n-1时，尽可能两个移动。


状态转移： AC(N) =AC(N-1)+AB(1)+CA(N-1)+BC(1)+AC(N-1)

         AB(N) = AC(N-1)+AB(1)+CB(N-1)

简化一下 AC(N) = =2*AC(N-1)+AB(N-1)2*AB(1)
      AB(N)  =2*AC(N-1)+AB(1)
## 答案
``` c
#include <stdio.h>
// 递归的方法不知道是int，long long类型原因还是什么计算超时
// unsigned long long AC(int a);
// unsigned long long AB(int a) {

//     if (a == 1) {
//         return 1;
//     }
// unsigned long long tmp = (2 * AC(a - 1) + AB(1))%1000000007;

//     return tmp ;
// }
// unsigned long long AC(int a) {

//     if (a == 1) {
//         return 2;
//     }
// unsigned long long tmp = (2 * AC(a - 1) + 2*AB(1)+AB(a-1))%1000000007;

//     return tmp ;
// }


int main() {
    int a;
    scanf("%d", &a);
// 从递归改
// unsigned long long a1 = AB(a);
// unsigned long long a2 = AC(a);
int a1=1;
int a2=2;

for(int i = 1;i<a;i++){
   long int tmp = a1;
   a1 =(2*a2+1)%1000000007;
   a2 = (2*a2+tmp+2)%1000000007;
}

   printf("%d %d",a1,a2);
}
// 87350326 444
// 2781183 3799167 15
```

## [题目网站](https://www.nowcoder.com/practice/cdf0808f841748faba058c8ef538c731?tpId=308&tqId=1116945&ru=/exam/oj&qru=/ta/algorithm-start/question-ranking&sourceUrl=%2Fexam%2Foj%3Fpage%3D1%26tab%3D%25E7%25AE%2597%25E6%25B3%2595%25E7%25AF%2587%26topicId%3D308)
