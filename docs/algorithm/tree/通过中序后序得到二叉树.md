# 通过中序后序得到二叉树

## 描述
给定一个二叉树的中序与后序遍历结果，请你根据两个序列构造符合这两个序列的二叉树。

## 思路
递归思想找到root。
因为中序= x个左子树 + root+y个右子树  后序= x个左子树 + y个右子树 + root；
通过遍历中序找到某一个点 中序[i] = 后序[最后一个]，这个i就是root对应的位置。
root->left就在 中序= x各左子树，后序= x个左子树中同上方法找。
root->right 在中序 = y个右子树，后续= y个右子树中找。

## 答案
``` c
/**
 * struct TreeNode {
 *	int val;
 *	struct TreeNode *left;
 *	struct TreeNode *right;
 * };
 */
/**
 * 代码中的类名、方法名、参数名已经指定，请勿修改，直接返回方法规定的值即可
 *
 *
 * @param inorder int整型一维数组 中序遍历序列
 * @param inorderLen int inorder数组长度
 * @param postorder int整型一维数组 后序遍历序列
 * @param postorderLen int postorder数组长度
 * @return TreeNode类
 */
struct TreeNode* buildTree(int* inorder, int inorderLen, int* postorder, int postorderLen ) {
    // write code here
struct TreeNode* p;
int index = 0;
if(inorderLen == 0){return NULL;}
while(inorder[index]!=postorder[inorderLen-1]){
    //最后一个
    index++;
    // 如果给的正确不会出现找不到的情况
}
p = malloc(sizeof(struct TreeNode));
p->val = inorder[index];
p->left = buildTree(inorder, index, postorder, postorderLen);
// 因为长度一致，中序= x个左子树 + root+y个右子树  ，后序= x个左子树 + y个右子树 + root；
// 所以找postorder [index -1]
p->right = buildTree(inorder+index+1, inorderLen -index-1, postorder+index, postorderLen-index-1) ;
return p;
}
```

## [题目网站](https://www.nowcoder.com/practice/ab8dde7f01f3440fbbb7993d2411a46b?tpId=308&tqId=2312538&ru=/exam/oj&qru=/ta/algorithm-start/question-ranking&sourceUrl=%2Fexam%2Foj%3Fpage%3D1%26tab%3D%25E7%25AE%2597%25E6%25B3%2595%25E7%25AF%2587%26topicId%3D308)
s