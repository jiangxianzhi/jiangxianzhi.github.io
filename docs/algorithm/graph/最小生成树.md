# 最小生成树

## 描述
一个有 n 户人家的村庄，有 m 条路相互连接着。村里现在要修路，每条路都有一个成本价格，现在请你帮忙计算下，最少需要花费多少钱，就能让这 n 户人家连接起来。


## 思路
1.krukal算法：先把所有路径从小到大排序，从小往大，将路径的起始点和终点添加入一个集合，倘若此集合中已有此点，那就舍弃此路，直到所有点都在集合中，停止。

2.prim算法：
先将所有点都放入集合B，然后从中取一点到集合A\
1.找到集合A中点到集合B点最短路径\
2.判断路径的另一个点是否在集合A中，不在就放入，在就表明会成换，跳过此点。
 \
 重复1，2直到所有点都到了集合A

## 答案
``` c
/**
 * 代码中的类名、方法名、参数名已经指定，请勿修改，直接返回方法规定的值即可
 *
 * 返回最小的花费代价使得这n户人家连接起来
 * @param n int n户人家的村庄
 * @param m int m条路
 * @param cost int二维数组 一维3个参数，表示连接1个村庄到另外1个村庄的花费的代价
 * @param costRowLen int cost数组行数
 * @param costColLen int* cost数组列数
 * @return int
 */

void mergeSort(int** arr, int left, int right) {
    if (left < right) {
        int mid = (left + right) / 2;
        mergeSort(arr, left, mid);
        mergeSort(arr, mid + 1, right);
        int temp[right - left + 1][ 3];
        int i = left;
        int j = mid + 1;
        int k = 0;
        while (i <= mid && j <= right) {
            if (arr[i][2] < arr[j][2]) {
                temp[k][1] = arr[i][1];
                temp[k][2] = arr[i][2];
                temp[k++][0] = arr[i++][0];
            }

            else {
                temp[k][1] = arr[j][1];
                temp[k][2] = arr[j][2];
                temp[k++][0] = arr[j++][0];
            }
        }
        while (i <= mid) {
            temp[k][1] = arr[i][1];
            temp[k][2] = arr[i][2];
            temp[k++][0] = arr[i++][0];
        }

        while (j <= right) {
            temp[k][1] = arr[j][1];
            temp[k][2] = arr[j][2];
            temp[k++][0] = arr[j++][0];
        }


        for (int i = 0; i < k; i++) {
            arr[left + i][0] = temp[i][0];
            arr[left + i][1] = temp[i][1];
            arr[left + i][2] = temp[i][2];
        }
    }
}
int miniSpanningTree(int n, int m, int** cost, int costRowLen,
                     int* costColLen ) {
    // write code here
    int column = costColLen[0] - 1; //数组下标2
    mergeSort(cost, 0, m - 1); //把他换成递归排序即可

    int arr[n + 1];
    for (int  i = 0; i <= n; i++) {
        arr[i] = i; //标记集合
    }

    int sum = 0;
    int count = 0;
    for (int i = 0; i < m; i++) {
        if (arr[cost[i][0]] != arr[cost[i][1]]) {
            sum += cost[i][column];
            count++;
            int  tmp  = arr[cost[i][0]];
            for (int k = 0; k < n + 1; k++) {
                if (arr[k] == tmp) {
                    arr[k] = arr[cost[i][1]];
                }
            }
        }
        if (count == n - 1 )  {
            return sum;
        }
    }
    return -1;

}


//prim,只通过了6/8案例，我也找不到原因在哪

#include <stdio.h>
int miniSpanningTree(int n, int m, int** cost, int costRowLen, int* costColLen ) {
    // write code here
    int g[n+1][n+1]; //邻接矩阵储存路径，方便后续检索
    for(int i = 0;i<n+1;i++){
        for(int j = 0;j<n+1;j++){
            g[i][j] = 10001;
            //不可达
        }
    }
    for(int i = 0;i<m;i++){
g[cost[i][0]][cost[i][1]] = cost[i][2];
g[cost[i][1]][cost[i][0]] = cost[i][2];
    }
    //     for(int i = 0;i<n+1;i++){
    //     for(int j = 0;j<n+1;j++){
    //     printf("%d ",g[i][j]);
    //         //不可达
    //     }
    //      printf("\n ");
    // }
int book[n+1];
for(int i = 0;i<n+1;i++){
    book[i] = 0;

}
int dist[n+1];
for(int i = 0;i<n+1;i++){
    dist[i] = 10001;

}
dist[1] = 0;
book[1] = 1;
for(int i = 2;i<n+1;i++){
  if(g[1][i]<10001){
      dist[i] = dist[i]<g[1][i]?dist[i]:g[1][i];
  }
}
int res = 0;
for(int i = 2;i<n+1;i++){
    int temp =  10001;
    int t = -1;
    for(int j = 2;j<n+1;j++){
        if(!book[j]&&dist[j]<temp){
            temp = dist[j];
            t = j;
        }
    }
      book[t] = 1;
      res+=dist[t];
      for(int j = 2;j<=n;j++){
       if(!book[j]&&g[t][j]<10001){
         dist[j] = dist[j]<g[t][j]?dist[j]:g[t][j];
       }
      }
}

return res;
}
```

## [题目网站](https://www.nowcoder.com/practice/735a34ff4672498b95660f43b7fcd628?tpId=308&tqId=1292435&ru=/exam/oj&qru=/ta/algorithm-start/question-ranking&sourceUrl=%2Fexam%2Foj%3Fpage%3D1%26tab%3D%25E7%25AE%2597%25E6%25B3%2595%25E7%25AF%2587%26topicId%3D308)
