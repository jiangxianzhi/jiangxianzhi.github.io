# 队循环队列列

## 描述
请你实现一个循环队列，该循环队列可利用的空间大小等于

n个int型变量的大小。
操作：
push x：将

x加入到循环队列尾端。若循环队列已满，输出"full"(不含引号)，否则不输出任何内容。保证

x为int型整数。
front：输出队首元素，队首不出队。若队列为空，输出"empty"(不含引号)。
pop：输出队首元素，且队首出队。若队列为空，输出"empty"(不含引号)。

## 思路
使用一个array，两个指针front，back表示队列，队列指针。
随着输入一直装
直到满，满的判断条件是 （back+1)%array.length = front
## 答案
``` c
#include <stdio.h>
#include <stdlib.h>
#include <stdbool.h>
#include <string.h>
typedef struct
{
    int* data;
    int front;
    int back;
    int capacity;//空间容量 = 固定长度 + 1 = n + 1，多开一个方便判空、判满
}cirQueue;
void QueueInit(cirQueue* obj,int n)
{
    obj->data = (int*)malloc(sizeof(int) * (n + 1));
    obj->front = obj->back = 0;
    obj->capacity = n + 1;
}
bool QueueIsFull(cirQueue* obj)
{
    //back尾的下一个是front头就是满了
    return (obj->back + 1) % obj->capacity == obj->front;
}
bool QueueIsEmpty(cirQueue* obj)
{
    return obj->front == obj->back;
}
bool QueuePush(cirQueue* obj,int x)
{
    if (QueueIsFull(obj))
    {
        return false;
    }

    obj->data[obj->back++] = x;
    //注意边界
    //模等一下置为有效范围
    obj->back %= obj->capacity;
    return true;
}
//empty传址用来判断循环队列是不是空
int QueueFront(cirQueue* obj,int* empty)
{
    if (QueueIsEmpty(obj))
    {
        *empty = 1;
        return 0;
    }
    return obj->data[obj->front];
}
int QueuePop(cirQueue* obj,int* empty)
{
    if (QueueIsEmpty(obj))
    {
        *empty = 1;
        return 0;
    }
    int front = obj->data[obj->front++];
    //注意边界
    //模等一下置为有效范围
    obj->front %= obj->capacity;

    return front;

}
int main()
{
    int n = 0,q = 0;
    cirQueue obj;
    scanf("%d%d",&n,&q);
    QueueInit(&obj,n);
    while (q--)
    {
        int empty = 0;
        char s[6] = { 0 };
        scanf("%s",&s);
        if (strcmp(s,"push") == 0)
        {
            int x = 0;
            scanf("%d",&x);
            bool flag = QueuePush(&obj,x);
            if (!flag)
            {
                printf("full\n");
            }

        }
        else if (strcmp(s,"pop") == 0)
        {
            int front = QueuePop(&obj,&empty);
            if (empty == 1)
            {
                printf("empty\n");
            }
            else
            {
                printf("%d\n",front);
            }
        }
        else
        {
            int front = QueueFront(&obj,&empty);
            if (empty == 1)
            {
                 printf("empty\n");
            }
            else
            {
                printf("%d\n",front);
            }
        }
    }
    return 0;
}
```

## [题目网站](https://www.nowcoder.com/practice/0a3a216e50004d8bb5da43ad38bcfcbf?tpId=308&tqId=2372963&ru=%2Fpractice%2F885c1db3e39040cbae5cdf59fb0e9382&qru=%2Fta%2Falgorithm-start%2Fquestion-ranking&sourceUrl=%2Fexam%2Foj%3Fpage%3D1%26tab%3D%25E7%25AE%2597%25E6%25B3%2595%25E7%25AF%2587%26topicId%3D308)
