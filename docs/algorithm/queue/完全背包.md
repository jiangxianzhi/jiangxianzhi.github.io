# 完全背包

## 描述
你有一个背包，最多能容纳的体积是V。

现在有n种物品，每种物品有任意多个，第i种物品的体积为
𝑣
,价值为
𝑤
（1）求这个背包至多能装多大价值的物品？
（2）若背包恰好装满，求至多能装多大价值的物品？

## 思路
从01背包来看，唯一区别是加倍多的物品，
于是在两层循环中再加一层循环用来倍数判断背包为V时可以装多少。
区别只在51行。
## 答案
``` c
#include <stdarg.h>
#include <stdio.h>
#include<malloc.h>

int main() {
    int volume;

    int quantity;
    scanf("%d %d", &quantity, &volume);
// 01背包
    int* a = (int*)malloc(sizeof(int) * (quantity + 1));
    int* b = (int*)malloc(sizeof(int) * (quantity + 1));
    a[0] = 0;
    b[0] = 0;
    for (int i = 1; i <= quantity; i++) {
        scanf("\n%d", &a[i]);
        scanf("\n%d", &b[i]);
    }



    int** dp = (int**)malloc(sizeof(int*) * (quantity + 1));
    for (int i = 0; i < quantity + 1; i++) {
        dp[i] = (int*)malloc(sizeof(int) * (volume + 1));
    }
    for (int i = 0; i < quantity + 1; i++) {
        for (int j = 0; j < volume + 1; j++) {
            dp[i][j] = 0;
        }
    }


    int** dp1 = (int**)malloc(sizeof(int*) * (quantity + 1));
    for (int i = 0; i < quantity + 1; i++) {
        dp1[i] = (int*)malloc(sizeof(int) * (volume + 1));
    }
    for (int i = 0; i < quantity + 1; i++) {
        for (int j = 0; j < volume + 1; j++) {
            dp1[i][j] = -100900;
            if (j == 0) {
                dp1[i][j] = 0;
            }
        }
    }

    for (int i = 1; i < quantity + 1; i++) {
        for (int j = 1; j <= volume; j++) {

            int max  = dp[i - 1][j];
            int max1 = dp1[i - 1][j];
            for (int k = 1; k * a[i] <= j; k++) {
                max = max > dp[i - 1][j - k * a[i]] + k * b[i] ? max : dp[i -
                        1][j - k * a[i]] + k * b[i];
                max1 = max1 > dp1[i - 1][j - k * a[i]] + k * b[i] ? max1 : dp1[i -
                        1][j - k * a[i]] + k * b[i];

            }
            dp[i][j] = max;
            dp1[i][j] = max1;

        }
        // printf("\n");
    }



//     for (int i = 1; i < quantity + 1; i++) {
//         for (int j = 1; j <= volume; j++) {
//    int max  = dp1[i - 1][j];
//         for(int k = 1;k*a[i]<=j;k++){
//             max =max > dp1[i - 1][j - k*a[i]] + k*b[i] ? max: dp1[i -
//                            1][j -k*a[i]] + k*b[i];

//         }
//            dp1[i][j] = max;


//         }
//         // printf("\n");
//     }

    printf("%d \n", dp[quantity][volume]);

    if (dp1[quantity][volume] > 0) {
        printf("%d", dp1[quantity][volume]);
    } else {
        printf("0");
    }
// for(int i =quantity;i>=quantity;i--){
// if(dp1[i][volume]==volume){
//     printf("%d",dp2[i][volume]);
//     return 0;
// }
// }

// for(int i = 1;i<quantity+1;i++){
//     for(int j = 1;j<=volume;j++){
//      printf("%d ",dp[i][j]);


//     }
//       printf("\n");
//     // printf("\n");
// }

    return 0;
}
```

## [题目网站](https://www.nowcoder.com/practice/735a34ff4672498b95660f43b7fcd628?tpId=308&tqId=1292435&ru=/exam/oj&qru=/ta/algorithm-start/question-ranking&sourceUrl=%2Fexam%2Foj%3Fpage%3D1%26tab%3D%25E7%25AE%2597%25E6%25B3%2595%25E7%25AF%2587%26topicId%3D308)
