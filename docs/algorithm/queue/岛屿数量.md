# 岛屿数量

## 描述
 给一个01矩阵，1代表是陆地，0代表海洋， 如果两个1相邻，那么这两个1属于同一个岛。我们只考虑上下左右为相邻。
岛屿: 相邻陆地可以组成一个岛屿（相邻:上下左右） 判断岛屿个数。\
例子：\
[[1,1,0,0,0],\
[0,1,0,1,1],\
[0,0,0,1,1],\
[0,0,0,0,0],\
[0,0,1,1,1]]\
3个

## 思路
遍历每个点+bfs \
拿到一个点，如果这个点是“1”，那么把他和他的四周全变成2，
直到遍历所有都是1的点都变成2
## 答案
``` c
/**
 * 代码中的类名、方法名、参数名已经指定，请勿修改，直接返回方法规定的值即可
 *
 * 判断岛屿数量
 * @param grid char字符型二维数组
 * @param gridRowLen int grid数组行数
 * @param gridColLen int* grid数组列数
 * @return int整型
 */
int solve(char** grid, int gridRowLen, int* gridColLen ) {
    // write code here

// 暂存队列
    int tmpArray[1000000][2] = {-1};
    int head = 0;
    int tail = 0;
    tail++;
//移动方向
    int dx[4] = {-1, 0, 1, 0};
    int dy[4] = {0, 1, 0, -1};
// 计数
    int count = 0;
    for (int i = 0; i < gridRowLen; i++) {
        for (int j = 0; j < gridColLen[0]; j++) {

            if (grid[i][j] == '1') {
                count++;
                // 把他附近的全部变成2
                grid[i][j] = 2;
                tmpArray[tail][0] = i;
                tmpArray[tail++][1] = j;
                while (head < tail) {
                    int x1 = tmpArray[head][0];
                    int y1 = tmpArray[head++][1];
                    for (int k = 0; k < 4; k++) {
                        int x2 = x1 + dx[k];
                        int y2 = y1 + dy[k];
                        if (x2 >= 0 && x2 < gridRowLen && y2 >= 0 && y2 < gridColLen[0] &&
                                grid[x2][y2] == '1') {
                            grid[x2][y2] = 2;
                            tmpArray[tail][0] = x2;
                            tmpArray[tail++][1] = y2;

                        }
                    }
                }
            }

        }
    }
    return  count;
}
```

## [题目网站](https://www.nowcoder.com/practice/0c9664d1554e466aa107d899418e814e?tpId=308&tqId=1024684&ru=/exam/oj&qru=/ta/algorithm-start/question-ranking&sourceUrl=%2Fexam%2Foj)
