# 走迷宫

## 描述
给定一个n×mn×m的网格，在网格中每次在不超过边界的情况下可以选择向上、向下、向左、向右移动一格。网格中的一些格子上放置有障碍物，放有障碍物的格子不能到达。求从(xs,ys)(xs​,ys​)到(xt,yt)(xt​,yt​)最少的移动次数。若不能到达，输出−1。
![alt text](image.png)
## 思路
bfs,先创建一个一样大小的二维数组，book[x][y]代表走到其位置x,y需要的步数，同时0表示没有走到过，
## 答案
``` c
// 输入： 5 5
// 1 1 5 5
// .....
// ****.
// .....
// **.**
// .....
// 从（1，1）位置到（5，5）位置
//  假设这是笛卡尔坐标
// 变成从（0，0）位置到（4，4）位置
// 输出最小步数为 12

// 思路：如同水滴从空中往下掉下，溅起阵阵涟漪
// 设置一个数组，所有探索过的坐标+边界坐标放入其中，
// 此坐标数组+范围限制 ，表示探索到此，就不会继续探索
// 设置另一个数组，表示所有到此的步数，选出最小的

#include <stdio.h>
#include <malloc.h>
#include <string.h>





int main() {

    int height, width;
    // 迷宫的高 宽
    scanf("%d %d", &height, &width);
    int sourceX, sourceY;
    // 源坐标
    scanf("%d %d", &sourceX, &sourceY);
    int desX, desY;
    // 目的坐标
    scanf("%d %d", &desX, &desY);

    sourceX = sourceX - 1;
    sourceY = sourceY - 1;
    desX = desX - 1;
    desY = desY - 1;


    char array[10001][1001];

    // 输入迷宫障碍分布

    for (int i = 0; i < height; i++) {

     scanf("%s", array[i]);
    }
    // for(int i = 0;i<5;i++){
    //     for(int j=0;j<5;j++){
    //         printf("%c",array[i][j]);
    //     }
    //     printf("\n");
    // }

    //  暂存队列   [[1,1],[2,2]....]
    // int** tempArray = (int**)malloc(1000 * 1000 * sizeof(int*));
    // for (int i = 0; i < 2; i++) {
    //     tempArray[i] = (int*)malloc(2 * sizeof(int));
    // }
    int tempArray[1001*1001][2]={0};
    int head = 0;
    int tail = 0;
    //二维到达过点图,0表示没有到达，其他表示到达过的步数
    // int** book = (int**)malloc(1001 * sizeof(int*));
    // for (int i = 0; i < 1001; i++) {
    //     book[i] = (int*)malloc(1001 * sizeof(int));
    // }
    int book[1001][1001] = {0};
    // for (int i = 0; i < 1001; i++) {
    //     for (int j = 0; j < 1001; j++) {
    //        printf("%d", book[i][j] );
    //     }
    // }
    //移动方向
    int dx[4] = {-1, 0, 1, 0};
    int dy[4] = {0, 1, 0, -1};
    //放入起始点
    book[sourceX][sourceY] = 1;
    // 为了防止往回走，设置成1，到最后需要减去1
    //     for (int i = 0; i < 1001; i++) {
    //     for (int j = 0; j < 1001; j++) {
    //        printf("%d", book[i][j] );
    //     }
    // }
    tempArray[0][0] = sourceX;
    tempArray[0][1] = sourceY;
    tail++;
    while (head < tail) {
        int x1;
        int  y1;
        x1 = tempArray[head][0];
        y1 = tempArray[head][1];
        head++; //出队列
        // 上下左右移动
        for (int i = 0; i < 4; i++) {
            int x2 = x1 + dx[i];
            int y2 = y1 + dy[i];
            if (x2 >= 0 && x2 < height && y2 >= 0 && y2 < width && book[x2][y2] == 0 &&
                    array[x2][y2] == '.') {
                book[x2][y2] = book[x1][y1]+1;
                tempArray[tail][0] = x2;
                tempArray[tail++][1] = y2;
            }
        }

    }
    if (book[desX][desY] == 0) {
        printf("-1");
    } else {
        printf("%d", book[desX][desY] - 1);
    }

    return 0;
}
```

## [题目网站](https://www.nowcoder.com/practice/e88b41dc6e764b2893bc4221777ffe64?tpId=308&tqId=2373924&ru=/exam/oj&qru=/ta/algorithm-start/question-ranking&sourceUrl=%2Fexam%2Foj)
